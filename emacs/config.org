#+TITLE: Tor's init

* Overview
I've made many attempts at structuring my Emacs configuration, so why not try once more.

Mistakes from the past:
1. Not descriptive enough comments with each package to know how to set it up properly.
   - Need to provide more context.
2. For a while we didn't use =straight.el=, but now we are so we should make use of everything it provides.
   - For example, we should use =straight-freeze-versions=.
3. Having an =init.el= file in addition to a =init.org= is too god-damn tempting!
   - When messing around with something, it's just too easy to mess around with `=init.el= instead of =init.org=.
   - One easy fix is to just remove the usage of =init.el= "completely", i.e. we use something like =(org-babel-load-file ...)= to evaluate the =init.org= (which then generates the =init.el=)
     - Good example: https://emacs.stackexchange.com/a/3147
   - So what we're going to do is that we'll include a /slightly/ customized version of =org-babel-load-file= for which we can specify which file to tangle to.
     - Allows us to define the full configs by specifying two different blocks:
       - =init-minimal.el=: defines a minimalist config which can be useful in scenarios where I don't need all the bells and whistles, e.g. if I want to do some remote editing through thet terminal.
       - =init-full.el=: the full init file I use on my personal devices.
 
So. The strategy will be as follows.
1. Different topics / packages get their own section.
2. Every src-block should have a unique name.
3. In the end, each "full" config should have it's ownn src-block where we use =:noweb yes= to include other src-blocks + =:comments noweb= so we can get a sense of where things came from by looking at the resulting =init.el= file.
4. We create a =Makefile= which does all the necessary stuff on a new installation, i.e.:
   1. Run =emacs= to tangle the file.
   2. Link the files we want linked, e.g. snippets.

Some other significant changes:
1. Replace the beloved =helm= with =vertico= + =marginalia= + =consult= + =embark=.
2. Repalce =org-ref= with =citar= and =org-cite.el=.

* General stuff
** Loading the config
As mentioned in the overview, we're going to take the following approach in main init file:
#+begin_src emacs-lisp
(require 'org)

;; A copy-paste from https://github.com/bzg/org-mode/blob/bd468136dd1a2172302b3ec980c5e6b6e327d683/lisp/org.el#L249-L279
;; but with the option of specifying the tangled file `file-out'.
;; Note that if blocks have specified a `:tangle' header, only those matching `file-out'
;; will indeed be tangled.'
(defun my/org-babel-load-file (file &optional file-out compile)
  "Load Emacs Lisp source code blocks in the Org FILE to FILE-OUT.
This function exports the source code using `org-babel-tangle'
and then loads the resulting file using `load-file'.  With
optional prefix argument COMPILE, the tangled Emacs Lisp file is
byte-compiled before it is loaded."
  (interactive "fFile to load: \nP")
  (let ((tangled-file (if file-out file-out (concat (file-name-sans-extension file) ".el"))))
    ;; Tangle only if the Elisp file is older than the Org file.
    ;; Catch the case when the .el file exists while the .org file is missing.
    (unless (file-exists-p file)
      (error "File to tangle does not exist: %s" file))
    (when (file-newer-than-file-p file tangled-file)
      (org-babel-tangle-file file
                             tangled-file
                             (rx string-start
                                 (or "emacs-lisp" "elisp")
                                 string-end))
      ;; Make sure that tangled file modification time is
      ;; updated even when `org-babel-tangle-file' does not make changes.
      ;; This avoids re-tangling changed FILE where the changes did
      ;; not affect the tangled code.
      (when (file-exists-p tangled-file)
        (set-file-times tangled-file)))
    (if compile
	    (progn
	      (byte-compile-file tangled-file)
	      (load-file (byte-compile-dest-file tangled-file))
	      (message "Compiled and loaded %s" tangled-file))
      (load-file tangled-file)
      (message "Loaded %s" tangled-file))))
#+end_src

Then, we simply add one more line to define which of the configs defined in this file we want. For example, if we want the minimal config:
#+begin_src emacs-lisp
;; Actually load the file we're interested in.
(my/org-babel-load-file
     (expand-file-name "config.org" user-emacs-directory)       ;; <= this file
     (expand-file-name "init-minimal.el" user-emacs-directory)) ;; <= the tangled file
#+end_src

** =~/.authinfo=
- Effectively a very simple plain-text password manager with encryption (if used right)
- Nicely supported in Emacs
  - Also comes with Python bindings (though py3 requires a bit of fiddling)

*** Python 3
- Can be useful for other integrations, e.g. I'm already sending emails using Emacs so if I write a Python script, it's nice if I can also just use the auth-information already present in my =~/.authinfo=
- Requires building =authinfo= from scratch
  - Also requires a particular fork: https://github.com/torfjelde/authinfo
- A simple =make install= copies the python package into =/usr/local/lib/python3.8/site-packages= which, unfortunately, isn't loaded (unless you're running the global python interpreter, which is rare these days).
  - A simple fix: =mv= the above to =/usr/local/lib/python3.8/dist-packages= which is loaded by every python installation (this is consider the /global/ repository for packages)
- Possible error: missing shared library =libauthinfo.so.0=
  - The =libauthinfo.so.0= file /should/ be present in =/usr/local/lib= or something equivalent (look for =libauthinfo.so.0= in the output for of the =make install=).
  - So this can be fixed by making sure that Python is indeed looking for shared libraries there, f.ex. by running =export LD_LIBRARY_PATH=/usr/local/lib:$LD_LIBRARY_PATH=.
- Also a useful resource if needed: https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources

** Email
*** Aim
There are two needs:
1. Retrieving emails.
   - Which we'll solve using *internet message access protocol (IMAP)*.
2. Sending emails.
   - Which we'll solve using *simple mail transport protocol (SMTP)*.
3. An interface (in Emacs) that unifies the two.

*** Retrieving emails using =offlineimap=

**** Integration with different providers

***** Outlook


****** =davmail=
- Effectively functions as a local email server, handling everything between you and Outlook, e.g. authentication.

#+begin_src shell :results output :wrap "src conf" :eval no
less ~/.offlineimaprc
#+end_src

#+RESULTS:
#+begin_src conf
[general]
accounts = account-1,account-2,account-3,account-4
maxsyncaccounts = 4
# Path to file with arbitrary Python code to load.
pythonfile = ~/.offlineimap.py

[Account account-2]
localrepository = account-2-local
remoterepository = account-2-exchange
# postsynchook = $HOME/.local/bin/check-email

[Repository account-2-local]
type = Maildir
localfolders = $HOME/mail/account-2@cam.ac.uk
# TODO: This is too aggressive.
nametrans = lambda folder: folder.replace('sent', 'Sent Items')

[Repository account-2-exchange]
type = IMAP
ssl = no
remotehost = localhost
remoteport = 1143
remoteuser = account-2@cam.ac.uk
remotepass = asdfas # it's not actually used
# createFolders = False # don't create folders remotely
# readonly = yes
# TODO: This is too aggressive.
nametrans = lambda folder: folder.replace('Sent Items', 'sent')
folderfilter = lambda folder: "Hermes" not in folder

[Account account-3]
localrepository = account-3-local
remoterepository = account-3-exchange
# postsynchook = $HOME/.local/bin/check-email

[Repository account-3-local]
type = Maildir
localfolders = $HOME/mail/account-3_coms@darwin.cam.ac.uk
# TODO: This is too aggressive.
nametrans = lambda folder: folder.replace('sent', 'Sent Items')

[Repository account-3-exchange]
type = IMAP
ssl = no
remotehost = localhost
remoteport = 1143
remoteuser = account-@cam.ac.uk/account-3_coms@darwin.cam.ac.uk
remotepass = asdfas # it's not actually used
# This is really stupid.
folderfilter = lambda folder: '/users/account-3_coms@darwin/cam/ac/uk/' not in folder
# createFolders = False # don't create folders remotely
# readonly = yes
# TODO: This is too aggressive.
nametrans = lambda folder: folder.replace('Sent Items', 'sent')

[Account account-1]
localrepository = account-1-local
remoterepository = account-1-remote
# postsynchook = $HOME/.local/bin/check-email

[Repository account-1-remote]
type = Gmail
remoteuser = account-1@gmail.com
remotepasseval = get_authinfo_password("smtp.gmail.com", "account-1@gmail.com", 587)
ssl = yes
sslcacertfile = OS-DEFAULT

[Repository account-1-local]
type = GmailMaildir
localfolders = $HOME/mail/account-1@gmail.com


[Account account-4]
localrepository = account-4-local
remoterepository = account-4-remote
# postsynchook = $HOME/.local/bin/check-email

[Repository account-4-remote]
type = Gmail
remoteuser = account-4@gmail.com
remotepasseval = get_authinfo_password("smtp.gmail.com", "account-4@gmail.com", 587)
ssl = yes
sslcacertfile = OS-DEFAULT

[Repository account-4-local]
type = GmailMaildir
localfolders = $HOME/mail/account-4@gmail.com
#+end_src

Note: the accounts in the above are anonymized so I can avoid a bit of spam, which is always nice.

******* Setup

***** Gmail

**** Authentication
- Using =~/.authinfo= to store the passwords (this is also used by Emacs' SMTP functionality)
- Need some setup to make =offlineimap= work nicely with this.

#+begin_src python :tangle ~/.offlineimap.py
#!/usr/bin/env python2
import re, os, sys


def get_authinfo_password(machine, login, port):
    "Extracts password from `~/.authinfo` for a given `machine`, `login`, `port` combination."
    s = "machine %s login %s port %s password (.*)$" % (machine, login, port)
    p = re.compile(s, flags=re.MULTILINE)
    # TODO: Use encrypted `.authinfo`.
    # authinfo = os.popen("gpg -q --no-tty -d ~/.authinfo.gpg").read()
    with open("/home/tor/.authinfo", "r") as f:
        authinfo = f.read()

    return p.search(authinfo).group(1)


if __name__ == "__main__":
    # Useful for testing.
    print(get_authinfo_password(sys.argv[1], sys.argv[2], sys.argv[3]))
#+end_src

And then we need to load this file in our =.offlineimaprc=:

#+begin_src shell :results output :wrap src conf :eval no :exports output
sed -n "1,5p" ~/.offlineimaprc
#+end_src

#+RESULTS:
#+begin_src conf
[general]
...
# Path to file with arbitrary Python code to load.
pythonfile = ~/.offlineimap.py
#+end_src

Now we can use the =remotepasseval= setting for the remote repositories to extract the auth info:

#+begin_src conf :eval no :exports code
# NOTE: Usually here we should be using `imap.gmail.com`, but we'll be needing the same auth info for SMTP so might as well just re-use
# rather than having multiple entries with the same info in the `~/.authinfo`.
remotepasseval = get_authinfo_password("smtp.gmail.com", "account-4@gmail.com", 587)
#+end_src

#+begin_warning
Some sources on the interwebs says to use =remotepass= in the above, but that doesn't seem to work. 
#+end_warning

*** Interfacing with emails using =notmuch=
- Provides a simple and powerful tagging system
- Treats everything as a single big "inbox", allowing us to easily filter based on different tags.
  - Personally find this very useful due to all the different email accounts I manage.

*** Setting up =cron= for periodic checking
#+begin_example
# Google won't be happy if we check the email too often, i.e. more frequently than ever 10 mins:
# https://support.google.com/mail/answer/7126229?visit_id=638005640878107785-764406290&p=BadCredentials&rd=2#cantsignin&zippy=%2Ci-cant-sign-in-to-my-email-client
*/10 *  * * *      offlineimap >> $HOME/.logs/offlineimap.log 2>&1
*/1  *  * * *      DISPLAY=:0 DBUS_SESSION_BUS_ADDRESS=unix:path=/run/user/$(id -u)/bus bash -lc check-email >> ~/.logs/check-mail.log 2>&1
#+end_example

This assumes that the script =check-email= is available in your =PATH=.
There are a couple of things to note here:
- =bash -lc= where
  - =l= is to "Make bash act as if it had been invoked as a login shell", e.g. it will load =~/.profile= and so on.
    - This is mucho importante if you want 
- From https://askubuntu.com/a/1274272: we need the weird stuff before the comand to make sure the =notify-send= works.


*** Writing messages
When writing a message, we're in, well =message-mode=. So that's where you should look if you want to change how things are handled.

**** Disabling automatic line-break
I find the automatic breaking of lines a bit annoying, in particular in this day and age when most email clients I send to will have some automatic formatting when viewed.

This can be "disabled"/controlled by setting the value of =message-fill-column= to whatever you desire, e.g. =999999=.

**** Signature
***** Old me
This is handled by =message-signature=, but the generally best approach is probably just to have a =~/.signature= file, which is automatically detected.

For example:

#+begin_example
All the best,
Tor
#+end_example

One annoying thing is that the signature-seperator is /hard-coded/ (I know, crazy) to be "--":

#+begin_src emacs-lisp :eval no
(defun message-insert-signature (&optional force)
  "Insert a signature.  See documentation for variable `message-signature'."
  (interactive (list 0))
  (let ((message-signature message-signature)
	(message-signature-file message-signature-file))
    ;; If called interactively and there's no signature to insert,
    ;; consult the global values to see whether there's anything they
    ;; have to say for themselves.  This can happen when using
    ;; `gnus-posting-styles', for instance.
    (when (and (null message-signature)
	       (null message-signature-file)
	       (eq force 0))
      (setq message-signature (default-value 'message-signature)
	    message-signature-file (default-value 'message-signature-file)))
    (let* ((signature
	    (cond
	     ((and (null message-signature)
		   (eq force 0))
	      (save-excursion
		(goto-char (point-max))
		(not (re-search-backward message-signature-separator nil t))))
	     ((and (null message-signature)
		   force)
	      t)
	     ((functionp message-signature)
	      (funcall message-signature))
	     ((listp message-signature)
	      (eval message-signature))
	     (t message-signature)))
	   signature-file)
      (setq signature
	    (cond ((stringp signature)
		   signature)
		  ((and (eq t signature) message-signature-file)
		   (setq signature-file
			 (if (and message-signature-directory
				  ;; don't actually use the signature directory
				  ;; if message-signature-file contains a path.
				  (not (file-name-directory
					message-signature-file)))
			     (expand-file-name message-signature-file
					       message-signature-directory)
			   message-signature-file))
		   (file-exists-p signature-file))))
      (when signature
	(goto-char (point-max))
	;; Insert the signature.
	(unless (bolp)
	  (newline))
	(when message-signature-insert-empty-line
	  (newline))
	(insert "-- ")  ;; FIXME: THIS GUY!
	(newline)
	(if (eq signature t)
	    (insert-file-contents signature-file)
	  (insert signature))
	(goto-char (point-max))
	(or (bolp) (newline))))))
#+end_src

#+RESULTS:

It's not the worst thing in the world though I guess.
***** [2023-05-23 Tue 12:20] Solution
Just define your own function for inserting the signature and use this, e.g.

#+begin_src emacs-lisp :eval no
(defun my/message-signature ()
  "Insert a signature."
  ;; We want to insert the signature ABOVE the quoted text,
  ;; so we first to go the message body.
  ;; NOTE: This insertion happens prior to inserting the quoted text.
  (message-goto-body)
  (insert "\n\n")
  (insert "All the best,\n")
  (insert "Tor\n"))

(setq message-signature 'my/message-signature)
#+end_src

*** Interacting with the outside of Emacs

**** TODO Emacs anywhere

**** =org-protocol.el= and [[https://github.com/sprig/org-capture-extension][org-capture-extension]] (for Firefox & Chrome)
1. Follow the instructions in the README for the extension.
2. Set up some capture templates (also described in the README).
   - NOTE: Example in the README uses =%c=, assuming the link passed to Emacs is added to the kill-ring. This seems to no longer be the case (if you look at the implementation =org-protocol-capture=); instead the link is added to =org-stored-links=, which means that we can include it in the capture template using =%a= or similar (see =org-capture-templates= for more info on alternatives).

*** Resulting config
#+name: el-mail-v3
#+begin_src emacs-lisp 
;; Email
;; Useful resources:
;; - https://kkatsuyuki.github.io/notmuch-conf/
;; - https://chrisdone.com/posts/emacs-mail/
;; - Multiple email setup:
;; - https://www.djcbsoftware.nl/code/mu/mu4e/Example-configurations.html#Example-configurations
;;   Example configurations using =mu=, but also invovles some setting of general mail variables
;;   and examples with `offlineimap'.
;; - https://emacs.stackexchange.com/a/12932
;;   Example using `smptmail-multi', which is _very_ useful.
;; - https://protesilaos.com/codelog/2021-05-15-emacs-notmuch/
;;   Demo of `notmuch'.
;; - https://sqrtminusone.xyz/posts/2021-02-27-gmail/
;;   Different approach to syncing with gmail using `lieer'. This also allows syncing tags with gmail.

(setq mail-user-agent 'message-user-agent)

;; Formatting in message-mode.
(setq message-fill-column 999999)

;; The quoted text is always below.
(setq message-cite-reply-position 'above)

;; Signature insertion.
(defun my/message-signature ()
  "Insert a signature."
  ;; We want to insert the signature ABOVE the quoted text,
  ;; so we first to go the message body.
  ;; NOTE: This insertion happens prior to inserting the quoted text.
  (message-goto-body)
  (insert "\n\n")
  (insert "All the best,\n")
  (insert "Tor\n"))

(setq message-signature 'my/message-signature)

;; Replies
(setq message-citation-line-function 'message-insert-formatted-citation-line)
(setq message-citation-line-format "\n\nOn %a, %d/%m/%Y, %f wrote:\n")

(use-package smtpmail-multi
  :ensure t)

;; Load the list of email accounts.
(load (expand-file-name "~/Dropbox/dotfiles/.emacs/emails.el"))

(require 'dash)
(defun my/make-smtpmail-multi-accounts-alist (accounts)
  "Make an alist of the form (NAME . (EMAIL BACKEND-CONFIG)) from ACCOUNTS."
  (-map
   (lambda (account)
     ;; Concatenate the email and the backend config, and then make a alist with the name as the key.
     (let ((email (plist-get account :email))
           (backend (plist-get account :backend)))
       `(,(plist-get account :name) . ,(cons email (alist-get backend my/email-backend-configs)))))
   accounts))

;; Define the different accounts and their corresponding settings.
(setq smtpmail-multi-accounts (my/make-smtpmail-multi-accounts-alist my/email-accounts))
;; Specify association rules for the different accounts.
(setq smtpmail-multi-associations (-map (lambda (x) (list (plist-get x :email) (plist-get x :name))) my/email-accounts))

;; Make the send mail function use `smtpmail-multi-send-it'.
(setq message-send-mail-function 'smtpmail-multi-send-it)
;; Useful for debugging purposes.
(setq smtpmail-debug-info t)

;; Allow usage of org-mode to compose emails.
(use-package org-mime)
(setq org-mime-library 'mml)

;; `notmuch' and related.
;; Docs: https://notmuchmail.org/doc/latest/notmuch-emacs.html
(use-package notmuch
  :custom
  (notmuch-always-prompt-for-sender t)  ;; promt for sender since I have multiple accounts
  (notmuch-search-oldest-first nil)     ;; sort by newest
  (notmuch-saved-searches my/notmuch-saved-searches)
  )

;; Adds nice integration with `org-mode', e.g. storing of links.
(use-package ol-notmuch
  :ensure t)

;; Usually have to have point at the HTML to show it,
;; which is a bit annoying.
(defun notmuch-show-view-html+ ()
  "Open the text/html part of the current message using
`notmuch-show-view-part'."
  (interactive)
  (save-excursion
    (goto-char
     (prop-match-beginning
      (text-property-search-forward
       :notmuch-part
       "text/html"
       (lambda (value notmuch-part)
         (equal (plist-get notmuch-part :content-type)
                value)))))
    (notmuch-show-view-part)))

;; Custom HTML renderer for email which simply converts into the source.
;; Adapted version of `mm-shr'.
;; FIXME: When activating the `web-mode', we end up disabling the `notmuch' keybindings.
(defun my/mm-raw-html (handle)
  (let (charset coding char document)
    (mm-with-part (or handle (setq handle (mm-dissect-buffer t)))
      ;; Identify encoding.
      (setq case-fold-search t)
      (or (setq charset
		        (mail-content-type-get (mm-handle-type handle) 'charset))
	      (progn
	        (goto-char (point-min))
	        (and (re-search-forward "\
<meta\\s-+http-equiv=[\"']?content-type[\"']?\\s-+content=[\"']?\
text/html;\\s-*charset=\\([^\t\n\r \"'>]+\\)[^>]*>" nil t)
		         (setq coding (mm-charset-to-coding-system (match-string 1)
							                               nil t))))
	      (setq charset mail-parse-charset))
      ;; Decode and insert contents if it's not ASCII.
      (when (and (or coding
		             (setq coding (mm-charset-to-coding-system charset nil t)))
		         (not (eq coding 'ascii)))
	    (insert (prog1
		            (decode-coding-string (buffer-string) coding)
		          (erase-buffer)
		          (set-buffer-multibyte t))))
      ;; Go back to start of the buffer.
      (goto-char (point-min))
      (while (re-search-forward
	          "&#\\(?:x\\([89][0-9a-f]\\)\\|\\(1[2-5][0-9]\\)\\);" nil t)
	    (when (setq char
		            (cdr (assq (if (match-beginning 1)
				                   (string-to-number (match-string 1) 16)
				                 (string-to-number (match-string 2)))
			                   mm-extra-numeric-entities)))
	      (replace-match (char-to-string char))))
      ;; Remove "soft hyphens".
      (goto-char (point-min))
      (while (search-forward "Â­" nil t)
	    (replace-match "" t t))
      ;; Set the `document' variable to the raw buffer contents.
      (setq document (buffer-string))
      )
    ;; Display.
    (save-restriction
      (narrow-to-region (point) (point))
      ;; Insert the HTML contents.
      (insert document)
      ;; Activate HTML mode.
      (web-mode)
      ;; Fontify so we get syntax highlighting and stuff.
      (font-lock-fontify-buffer)
      ;; Indent the buffer.
      (save-excursion
        (indent-region (point-min) (point-max) nil))
      ;; If we're at the beginning of the buffer, i.e. it's empty,
      ;; insert a newline.
      (unless (bobp)
	    (insert "\n"))
      (mm-handle-set-undisplayer
       handle
       (let ((min (point-min-marker))
             (max (point-max-marker)))
         (lambda ()
	       (let ((inhibit-read-only t))
	         (delete-region min max))))))))

;; (setq mm-text-html-renderer 'my/mm-raw-html)
(setq mm-text-html-renderer 'shr)

;; Handle attachments a bit better.
;; Source: https://notmuchmail.org/emacstips/#index2h2
(defun tor/mm-pipe-- (handle cmd)
  ;; conveniently, '-' '-' a args to pdftotext and docx2txt.pl work fine
  ;; fixme: naming inconsistency (fn name and buffer name)
  (let ((buffer (get-buffer-create "*attachment-to-text*")))
    (with-current-buffer buffer
      (setq buffer-read-only nil)
      (erase-buffer))
    (with-temp-buffer
      ;; "based on mm-pipe-part in mm-decode.el"
      (mm-with-unibyte-buffer
        (mm-insert-part handle)
        (mm-add-meta-html-tag handle)
        (let ((coding-system-for-write 'binary))
          (call-process-region (point-min) (point-max)
                               cmd nil buffer nil "-" "-"))))
    (pop-to-buffer buffer)
    (goto-char (point-min))
    (text-mode)
    (visual-line-mode)
    (view-mode)))

(defun tor/notmuch-show-pop-attachment-to-buffer ()
  ;; "based on `notmuch-show-apply-to-current-part-handle'"
  (interactive)
  (let ((handle (notmuch-show-current-part-handle)))
    (unwind-protect
        (pcase (car (nth 1 handle))
          ("application/pdf"
           ;; Save and open.
           ;; FIXME: Fails if we decide not to save the file, e.g.
           ;; because it would override an existing one.
           (find-file (notmuch-show-save-part))
           ;; Alternative: convert to text and open that buffer instead.
           ;; (tor/mm-pipe-- handle "pdftotext")
           )
          ("image/png"
           ;; Save and open.
           (find-file (notmuch-show-save-part))
           )
          ("application/vnd.openxmlformats-officedocument.wordprocessingml.document"
           (tor/mm-pipe-- handle "docx2txt"))
          (_ (notmuch-show-save-part)))
      (kill-buffer (mm-handle-buffer handle)))))

(setq notmuch-show-part-button-default-action
      #'tor/notmuch-show-pop-attachment-to-buffer)

;; Overrides `org-notmuch-open' which apparently expects 2 arguments, while `org-mode'
;; (at least the one I've currently installed), expects 1 argument.
;; The 2nd argument in `org-notmuch-open' isn't used for anything anyways, so we might
;; as well just define one that ought to be compatible with either 1 or 2 args.
(defun org-notmuch-open (path &rest)
  "Follow a notmuch message link specified by PATH."
  (funcall org-notmuch-open-function path))
#+end_src

** Org

*** =org=


*** =org-ref=

**** Some utilities
#+begin_src emacs-lisp
(defun my/org-ref-copy-bibtex-of-key-at-point ()
  (interactive)
  (save-window-excursion
    (let ((bibtex-completion-bibliography (org-ref-find-bibliography)))
	   (bibtex-completion-show-entry (list (org-ref-get-bibtex-key-under-cursor)))
	   (bibtex-copy-entry-as-kill)
	   (kill-new (pop bibtex-entry-kill-ring)))))

(defun my/org-ref-used-citations-to-bibtex-buffer ()
  (interactive)
  (let ((bibtex-completion-bibliography (org-ref-find-bibliography))
        (refs (my/org-ref-get-references-used)))
    (with-current-buffer (get-buffer-create "*BibTex export*")
      ;; Clear it.
      (erase-buffer)

      ;; Do the stuff.
      (-map (lambda (ref)
              (save-window-excursion
                (bibtex-completion-show-entry (list ref))
                (bibtex-copy-entry-as-kill))
              ;; Check that we're back in the "*BibTex export*" buffer.
              (when (not (string= (buffer-name) "*BibTex export*"))
                (error "Something went wrong."))
              ;; Insert (pop bibtex-entry-kill-ring) into the "*BibTex export*" buffer.
              (insert (pop bibtex-entry-kill-ring)))
            refs))

    ;; Display the buffer.
    (pop-to-buffer "*BibTex export*")
    (bibtex-mode)))

(defun my/org-ref-get-references-used ()
  (save-match-data
    (let ((links (org-ref-get-cite-links)))
    ;; Now we extract the path and strip away the `&' symbol.
    (mapcar (lambda (link)
              (let ((path (org-element-property :path link)))
                (if (string-match "&" path)
                    (substring path 1 (length path))
                  path)))
            links))))
#+end_src

*** =org-reveal.el=
#+begin_src emacs-lisp
(use-package ox-reveal
  ;; NOTE: Necessary because otherwise we end up trying to load `org-reveal'
  ;; which is actually not provided (despite the name of the project).
  :straight (ox-reveal :host github :repo "torfjelde/org-reveal" :branch "torfjelde/develop")
  :custom
  (org-reveal-extract-mathjax-version-from-url t)
  (org-reveal-mathjax3-version "3.2.2")
  (org-reveal-mathjax3-config
   (json-encode
    '((loader (load . ["[tex]/physics" "[tex]/color"]))
      (tex
       (inlineMath ["$" "$"] ["\\(" "\\)"])
       (packages ("[+]" . ["physics" "color"]))
       (macros (ind . "\\unicode{x1D7D9}"))
       ))))
  (org-reveal-plugin-to-name '((chalkboard . RevealChalkboard)))
  (org-reveal-external-plugins '((RevealChalkboard . ("%splugin/chalkboard/plugin.js" "%splugin/chalkboard/style.css"))))
  )
#+end_src

*** =org-contrib.el=

**** =ox-extra.el=
#+begin_src emacs-lisp
(use-package org-contrib
  :config
  (require 'ox-extra)
  ;; Usage of `:ignore' tag on a headline means that this headline will be ignored
  ;; upon export, _but_ its children will still be exported.
  (ox-extras-activate '(ignore-headlines))
  )
#+end_src





* Resulting configs

** Full config
#+name: el-full-init
#+begin_src emacs-lisp :comments noweb :tangle init-full.el

#+end_src


** Minimalist config
#+name: el-minimal-init
#+begin_src emacs-lisp :comments noweb :tangle init-minimal.el

#+end_src


